(window.webpackJsonp=window.webpackJsonp||[]).push([[391],{701:function(t,e,s){"use strict";s.r(e);var a=s(15),n=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"priority"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#priority"}},[t._v("#")]),t._v(" Priority")]),t._v(" "),e("p",[t._v("首先我们要知道一点，在React16.4的分支上，这部分代码是不存在的，在React发布了16.5版本之后，我切换到了master分支的代码，这部分代码才实现。那么这部分代码是干嘛的呢？答案是"),e("code",[t._v("sequense")]),t._v("，在17年末到18年初，FB的Dan就四处进行分享，主要内容就是会在React17版本中发布的一些新功能，一个就是"),e("code",[t._v("AsyncRendering")]),t._v("，还有一个就是"),e("code",[t._v("sequense")]),t._v("。")]),t._v(" "),e("h3",{attrs:{id:"sequense"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sequense"}},[t._v("#")]),t._v(" sequense")]),t._v(" "),e("p",[t._v("首先来讲一下什么是"),e("code",[t._v("sequense")]),t._v("，他提供了React在"),e("code",[t._v("render")]),t._v("方法中进行异步处理的功能，比如如下的例子")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("DataReander")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" data "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" SomeProvider"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'dataId'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("info"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nReactDOM"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Placehodler fallback"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'something render able'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("DataReander "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Placeholder"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  document"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("getElementById")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'app'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),e("p",[e("code",[t._v("SomeProvider.get('dataId')")]),t._v("这里是一个异步获取数据的操作，按照正常的逻辑，React的"),e("code",[t._v("render")]),t._v("方法是同步渲染的，所以在渲染的时候"),e("code",[t._v("data")]),t._v("肯定还是不存在的，一般来说获取数据会返回一个"),e("code",[t._v("Promise")]),t._v("。")]),t._v(" "),e("p",[t._v("那么React如何处理这个情况呢？"),e("code",[t._v("SomeProvider.get('dataId')")]),t._v("会"),e("code",[t._v("throw")]),t._v("这个"),e("code",[t._v("promise")]),t._v("，或者你可以让这个方法返回一个"),e("code",[t._v("promise")]),t._v("，然后你判断他是否是"),e("code",[t._v("promise")]),t._v("，并自己"),e("code",[t._v("throw")]),t._v("，比如：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("DataReander")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" data "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" SomeProvider"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'dataId'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data is promise"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 伪代码")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("throw")]),t._v(" data\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("info"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("这是第一个React引入这个概念想要解决的问题")]),t._v(" "),e("h3",{attrs:{id:"async-rendering"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#async-rendering"}},[t._v("#")]),t._v(" Async Rendering")]),t._v(" "),e("p",[t._v("如果仅仅是因为"),e("code",[t._v("sequense")]),t._v("那么还不需要引入这么复杂的概念，因为渲染都是同步的，只需要考虑到"),e("code",[t._v("promise")]),t._v("的"),e("code",[t._v("resolve")]),t._v("就可以了。但是如果结合上"),e("code",[t._v("Async Rendering")]),t._v("，就变得很复杂。")]),t._v(" "),e("p",[t._v("先来说一下"),e("code",[t._v("Async Rendering")]),t._v("的概念，在进行节点非常多的"),e("code",[t._v("React")]),t._v("树的渲染过程中，因为任务非常复杂，可能导致消耗的时间很长，因为JS是单线程的，如果"),e("code",[t._v("React")]),t._v("一次"),e("code",[t._v("setState")]),t._v("导致非常多的节点需要重新计算并渲染，那么可能会影响页面动画的渲染效果，导致卡帧的现象。")]),t._v(" "),e("p",[t._v("所以React提供了这个功能，这个功能告诉我们这次"),e("code",[t._v("setState")]),t._v("的优先级不高，如果执行时间较长，可以中间中断一下，等渲染引擎有空了再来执行我。而这个能实现的核心就是"),e("code",[t._v("requestIdleCallback")]),t._v("，React会给异步任务一个计时，比如"),e("code",[t._v("33")]),t._v("毫秒的"),e("code",[t._v("30")]),t._v("帧稳定帧时间，在"),e("code",[t._v("33")]),t._v("毫秒内如果任务没执行完会被中断，把执行权给浏览器去执行动画什么之类的，然后把任务放到"),e("code",[t._v("requestIdleCallback")]),t._v("的回调里面，等有空了再来执行。")]),t._v(" "),e("p",[t._v("而为了防止这个任务永远处于没空执行的状态，React会给每次任务生成的时候设置一个过期时间。根据优先级的不同，会有不同的过期时间")]),t._v(" "),e("ol",[e("li",[t._v("同步任务优先级最高，所以过期时间是"),e("code",[t._v("1")]),t._v("，也就是直接执行不考虑中断的情况")]),t._v(" "),e("li",[t._v("异步模式下的"),e("code",[t._v("InteractiveUpdates")]),t._v("过期时间是"),e("code",[t._v("22")]),t._v("毫秒，这类操作是响应事件的操作，所以优先级较高")]),t._v(" "),e("li",[t._v("一步模式，502毫秒")])]),t._v(" "),e("p",[t._v("另外开发模式下"),e("code",[t._v("InteractiveUpdates")]),t._v("的过期时间会稍微长一些，52毫秒，让开发者可以更容易发现卡顿现象。")]),t._v(" "),e("p",[t._v("所以如果结合了"),e("code",[t._v("Async Rendering")]),t._v("和"),e("code",[t._v("sequense")]),t._v("，在异步模式下出现了中断的任务，那么这时候就要考虑这些时间了：")]),t._v(" "),e("ol",[e("li",[e("code",[t._v("placehodler")]),t._v("的"),e("code",[t._v("delayMs")]),t._v("设置的超时时间")]),t._v(" "),e("li",[t._v("Promise的"),e("code",[t._v("resolve")]),t._v("的时间")]),t._v(" "),e("li",[t._v("在"),e("code",[t._v("Promise")]),t._v("正在pending的情况下有新的任务进来的时间")])]),t._v(" "),e("p",[t._v("同时还存在一个问题，那就是任务过期之后会强制执行这个任务，那么有那么多不同的等待时间在，应该根据哪个来判断任务是否执行呢？")]),t._v(" "),e("p",[e("strong",[t._v("这就是React引入这个概念的原因")])]),t._v(" "),e("h1",{attrs:{id:"priority的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#priority的实现"}},[t._v("#")]),t._v(" Priority的实现")]),t._v(" "),e("p",[t._v("在React中引入了一系列时间记录参数来判断最终的过期时间应该是哪个，我们先来看一下参数")]),t._v(" "),e("ol",[e("li",[e("code",[t._v("earliestPendingTime")])]),t._v(" "),e("li",[e("code",[t._v("latestPendingTime")])]),t._v(" "),e("li",[e("code",[t._v("earliestSuspendedTime")])]),t._v(" "),e("li",[e("code",[t._v("latestSuspendedTime")])]),t._v(" "),e("li",[e("code",[t._v("latestPingedTime")])])]),t._v(" "),e("p",[t._v("首先解释几个概念")]),t._v(" "),e("h5",{attrs:{id:"pending"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pending"}},[t._v("#")]),t._v(" pending")]),t._v(" "),e("p",[e("code",[t._v("pending")]),t._v("是指目前正在执行的任务的过期时间，在一个新的任务被创建的时候，会通过"),e("code",[t._v("markPendingPriorityLevel")]),t._v("进行记录，React只会记录最早的和最老的过期时间。")]),t._v(" "),e("h5",{attrs:{id:"suspended"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#suspended"}},[t._v("#")]),t._v(" suspended")]),t._v(" "),e("p",[e("code",[t._v("suspended")]),t._v("是挂起的意思，对应的也就是"),e("code",[t._v("suquense")]),t._v("的情况，在一个任务被挂起的时候，会记录这个挂起任务的过期时间。类似"),e("code",[t._v("pending")]),t._v("，他也只记录最早和最老的")]),t._v(" "),e("h5",{attrs:{id:"pinged"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pinged"}},[t._v("#")]),t._v(" pinged")]),t._v(" "),e("p",[t._v("在挂起任务的Promise resolve的时候，会判断当时设置的过期时间是否处于目前整个应用的过期时间之间。如果是的话这个时间会被设置为"),e("code",[t._v("pingedTime")]),t._v("，如果不在这个区间内，则会重新计算任务的过期时间，并按照节点是否是异步渲染的模式被安排到更新队列当中。"),e("strong",[t._v("相当于执行了一次新的"),e("code",[t._v("setState")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);