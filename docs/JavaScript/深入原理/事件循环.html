<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>事件循环 | 王亚宁的个人学习</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.1a8e0fbc.css" as="style"><link rel="preload" href="/assets/js/app.d6181b04.js" as="script"><link rel="preload" href="/assets/js/2.733019b2.js" as="script"><link rel="preload" href="/assets/js/25.85eb4b5d.js" as="script"><link rel="prefetch" href="/assets/js/10.3fb17185.js"><link rel="prefetch" href="/assets/js/11.df13f98f.js"><link rel="prefetch" href="/assets/js/12.b66383ee.js"><link rel="prefetch" href="/assets/js/13.0a23e10b.js"><link rel="prefetch" href="/assets/js/14.366841cb.js"><link rel="prefetch" href="/assets/js/15.d25f8a51.js"><link rel="prefetch" href="/assets/js/16.08f21664.js"><link rel="prefetch" href="/assets/js/17.1061e257.js"><link rel="prefetch" href="/assets/js/18.8a4c6d2b.js"><link rel="prefetch" href="/assets/js/19.85149716.js"><link rel="prefetch" href="/assets/js/20.3eb847ee.js"><link rel="prefetch" href="/assets/js/21.15e6c8fe.js"><link rel="prefetch" href="/assets/js/22.d19be237.js"><link rel="prefetch" href="/assets/js/23.f58c749b.js"><link rel="prefetch" href="/assets/js/24.31132eef.js"><link rel="prefetch" href="/assets/js/26.968591fe.js"><link rel="prefetch" href="/assets/js/27.aff14ef6.js"><link rel="prefetch" href="/assets/js/28.ce9ce64f.js"><link rel="prefetch" href="/assets/js/29.8db63817.js"><link rel="prefetch" href="/assets/js/3.64b6d7b3.js"><link rel="prefetch" href="/assets/js/30.2ba176e5.js"><link rel="prefetch" href="/assets/js/31.9644ac6d.js"><link rel="prefetch" href="/assets/js/32.52962b52.js"><link rel="prefetch" href="/assets/js/33.d9c1010b.js"><link rel="prefetch" href="/assets/js/34.86d8e9ce.js"><link rel="prefetch" href="/assets/js/35.397ddd83.js"><link rel="prefetch" href="/assets/js/36.1df7fc65.js"><link rel="prefetch" href="/assets/js/37.e79a8c36.js"><link rel="prefetch" href="/assets/js/38.ff716bf7.js"><link rel="prefetch" href="/assets/js/39.84c24b83.js"><link rel="prefetch" href="/assets/js/4.da3ef268.js"><link rel="prefetch" href="/assets/js/40.0b62ac91.js"><link rel="prefetch" href="/assets/js/41.cdb6b048.js"><link rel="prefetch" href="/assets/js/42.836f874d.js"><link rel="prefetch" href="/assets/js/43.b50e313c.js"><link rel="prefetch" href="/assets/js/44.b899823e.js"><link rel="prefetch" href="/assets/js/45.58edc359.js"><link rel="prefetch" href="/assets/js/46.bbbe1817.js"><link rel="prefetch" href="/assets/js/47.80a908bf.js"><link rel="prefetch" href="/assets/js/48.f6d4302a.js"><link rel="prefetch" href="/assets/js/49.42c4f7d9.js"><link rel="prefetch" href="/assets/js/5.dac787d8.js"><link rel="prefetch" href="/assets/js/50.3c483839.js"><link rel="prefetch" href="/assets/js/51.65b0a3ae.js"><link rel="prefetch" href="/assets/js/52.e8eebaf5.js"><link rel="prefetch" href="/assets/js/53.71ce7e45.js"><link rel="prefetch" href="/assets/js/54.70b9b23b.js"><link rel="prefetch" href="/assets/js/55.902a834f.js"><link rel="prefetch" href="/assets/js/56.ccfea6ae.js"><link rel="prefetch" href="/assets/js/57.98a426e4.js"><link rel="prefetch" href="/assets/js/58.48d2d884.js"><link rel="prefetch" href="/assets/js/59.64f96906.js"><link rel="prefetch" href="/assets/js/6.820ab661.js"><link rel="prefetch" href="/assets/js/60.79e25a48.js"><link rel="prefetch" href="/assets/js/61.702571c0.js"><link rel="prefetch" href="/assets/js/62.f4d96841.js"><link rel="prefetch" href="/assets/js/63.b239a95e.js"><link rel="prefetch" href="/assets/js/64.9376960a.js"><link rel="prefetch" href="/assets/js/65.40597fe8.js"><link rel="prefetch" href="/assets/js/66.aae02cce.js"><link rel="prefetch" href="/assets/js/67.dbb30cd0.js"><link rel="prefetch" href="/assets/js/68.705ba71c.js"><link rel="prefetch" href="/assets/js/69.79d30799.js"><link rel="prefetch" href="/assets/js/7.22edff0c.js"><link rel="prefetch" href="/assets/js/70.68b46478.js"><link rel="prefetch" href="/assets/js/71.5874de26.js"><link rel="prefetch" href="/assets/js/72.01d3455f.js"><link rel="prefetch" href="/assets/js/8.8733fc27.js"><link rel="prefetch" href="/assets/js/9.76eb16d3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1a8e0fbc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">王亚宁的个人学习</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/react/react.html" class="nav-link">
  我学习的react
</a></div><div class="nav-item"><a href="/vue/v-model.html" class="nav-link">
  我学习的vue
</a></div><div class="nav-item"><a href="/JavaScript/深入原理/闭包.html" class="nav-link">
  我学习的javascript
</a></div><div class="nav-item"><a href="https://w-yaning.github.io/react-book/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Jokcy react 文档
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/react/react.html" class="nav-link">
  我学习的react
</a></div><div class="nav-item"><a href="/vue/v-model.html" class="nav-link">
  我学习的vue
</a></div><div class="nav-item"><a href="/JavaScript/深入原理/闭包.html" class="nav-link">
  我学习的javascript
</a></div><div class="nav-item"><a href="https://w-yaning.github.io/react-book/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Jokcy react 文档
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/JavaScript/深入原理/闭包.html" class="sidebar-link">闭包</a></li><li><a href="/JavaScript/深入原理/变量声明提升.html" class="sidebar-link">变量声明提升</a></li><li><a href="/JavaScript/深入原理/继承.html" class="sidebar-link">继承</a></li><li><a href="/JavaScript/深入原理/上下文与作用域.html" class="sidebar-link">上下文与作用域</a></li><li><a href="/JavaScript/深入原理/事件循环.html" class="active sidebar-link">事件循环</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/JavaScript/深入原理/事件循环.html#概念" class="sidebar-link">概念</a></li><li class="sidebar-sub-header"><a href="/JavaScript/深入原理/事件循环.html#浏览器内核" class="sidebar-link">浏览器内核</a></li><li class="sidebar-sub-header"><a href="/JavaScript/深入原理/事件循环.html#宏任务和微任务" class="sidebar-link">宏任务和微任务</a></li><li class="sidebar-sub-header"><a href="/JavaScript/深入原理/事件循环.html#浏览器事件循环" class="sidebar-link">浏览器事件循环</a></li><li class="sidebar-sub-header"><a href="/JavaScript/深入原理/事件循环.html#node-js-事件循环" class="sidebar-link">Node.js 事件循环</a></li><li class="sidebar-sub-header"><a href="/JavaScript/深入原理/事件循环.html#node-的事件循环机制-来自-node-js事件循环eventloop机制-异步原理" class="sidebar-link">Node 的事件循环机制（来自 Node.js事件循环EventLoop机制 异步原理）</a></li><li class="sidebar-sub-header"><a href="/JavaScript/深入原理/事件循环.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/JavaScript/深入原理/原型与原型链.html" class="sidebar-link">原型原型链</a></li><li><a href="/JavaScript/深入原理/执行上下文.html" class="sidebar-link">执行上下文与执行上下文栈</a></li><li><a href="/JavaScript/深入原理/作用域与作用域链.html" class="sidebar-link">作用域与作用域链</a></li><li><a href="/JavaScript/深入原理/this指向.html" class="sidebar-link">this 指向</a></li><li><a href="/JavaScript/手写系列/Ajax.html" class="sidebar-link">实现 Ajax</a></li><li><a href="/JavaScript/手写系列/apply.html" class="sidebar-link">实现 apply</a></li><li><a href="/JavaScript/手写系列/bind.html" class="sidebar-link">实现 bind</a></li><li><a href="/JavaScript/手写系列/call.html" class="sidebar-link">实现 call</a></li><li><a href="/JavaScript/手写系列/debounce.html" class="sidebar-link">实现 debounce (函数防抖)</a></li><li><a href="/JavaScript/手写系列/deepClone.html" class="sidebar-link">实现深度克隆 deepClone</a></li><li><a href="/JavaScript/手写系列/EventEmitter.html" class="sidebar-link">实现 EventEmitter</a></li><li><a href="/JavaScript/手写系列/instanceof.html" class="sidebar-link">实现一个 instanceof</a></li><li><a href="/JavaScript/手写系列/jsonp.html" class="sidebar-link">实现 jsonp</a></li><li><a href="/JavaScript/手写系列/new.html" class="sidebar-link">实现 new</a></li><li><a href="/JavaScript/手写系列/Promise.html" class="sidebar-link">实现 Promise</a></li><li><a href="/JavaScript/手写系列/Scheduler.html" class="sidebar-link">实现调度器 Scheduler</a></li><li><a href="/JavaScript/手写系列/throttle.html" class="sidebar-link">实现 throttle  (函数节流)</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h1> <h2 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h2> <h3 id="进程与线程"><a href="#进程与线程" class="header-anchor">#</a> 进程与线程</h3> <p>进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位。</p> <p>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</p> <p>一个进程的内存空间是共享的，每个线程都可用这些共享内存。</p> <h3 id="多进程与多线程"><a href="#多进程与多线程" class="header-anchor">#</a> 多进程与多线程</h3> <p><strong>多进程</strong>：在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如你可以听歌的同时，打开编辑器敲代码，编辑器和听歌软件的进程之间丝毫不会相互干扰。</p> <p><strong>多线程</strong>：程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。</p> <h2 id="浏览器内核"><a href="#浏览器内核" class="header-anchor">#</a> 浏览器内核</h2> <p>简单来说浏览器内核是通过取得页面内容、整理信息（应用CSS）、计算和组合最终输出可视化的图像结果，通常也被称为渲染引擎。</p> <p>浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p> <ul><li>GUI 渲染线程</li> <li>JavaScript 引擎线程</li> <li>定时触发器线程</li> <li>事件触发线程</li> <li>异步http请求线程</li></ul> <h3 id="_1-gui渲染线程"><a href="#_1-gui渲染线程" class="header-anchor">#</a> 1.GUI渲染线程</h3> <ul><li>主要负责页面的渲染，解析 HTML、CSS，构建 DOM 树，布局和绘制等。</li> <li>当界面需要重绘或者由于某种操作引发回流时，将执行该线程。</li> <li>该线程与 JS 引擎线程互斥，当执行 JS 引擎线程时，GUI 渲染会被挂起，当任务队列空闲时，主线程才会去执行 GUI 渲染。</li></ul> <h3 id="_2-js引擎线程"><a href="#_2-js引擎线程" class="header-anchor">#</a> 2.JS引擎线程</h3> <ul><li>该线程当然是主要负责处理 JavaScript 脚本，执行代码。</li> <li>也是主要负责执行准备好待执行的事件，即定时器计数结束，或者异步请求成功并正确返回时，将依次进入任务队列，等待 JS 引擎线程的执行。</li> <li>当然，该线程与 GUI 渲染线程互斥，当 JS 引擎线程执行 JavaScript 脚本时间过长，将导致页面渲染的阻塞。</li></ul> <h3 id="_3-定时器触发线程"><a href="#_3-定时器触发线程" class="header-anchor">#</a> 3.定时器触发线程</h3> <ul><li>负责执行异步定时器一类的函数的线程，如： setTimeout，setInterval。</li> <li>主线程依次执行代码时，遇到定时器，会将定时器交给该线程处理，当计数完毕后，事件触发线程会将计数完毕后的事件加入到任务队列的尾部，等待 JS 引擎线程执行。</li></ul> <h3 id="_4-事件触发线程"><a href="#_4-事件触发线程" class="header-anchor">#</a> 4.事件触发线程</h3> <ul><li>主要负责将准备好的事件交给 JS引擎线程执行。</li></ul> <p>比如 <code>setTimeout</code> 定时器计数结束， ajax 等异步请求成功并触发回调函数，或者用户触发点击事件时，该线程会将整装待发的事件依次加入到任务队列的队尾，等待 JS 引擎线程的执行。</p> <h3 id="_5-异步http请求线程"><a href="#_5-异步http请求线程" class="header-anchor">#</a> 5.异步http请求线程</h3> <ul><li>负责执行异步请求一类的函数的线程，如： <code>Promise</code>，axios，ajax等。</li> <li>主线程依次执行代码时，遇到异步请求，会将函数交给该线程处理，当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的尾部，等待JS引擎线程执</li></ul> <h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="header-anchor">#</a> 宏任务和微任务</h2> <h3 id="宏任务-macrotask"><a href="#宏任务-macrotask" class="header-anchor">#</a> 宏任务 macrotask：</h3> <ul><li>script(整体代码)，</li> <li>事件回调，</li> <li>XHR回调，</li> <li>定时器（<code>setTimeout</code>/<code>setInterval</code>），</li> <li><code>setImmediate</code>（Node.js 独有）</li> <li>IO 操作，</li> <li>UI render</li></ul> <h3 id="微任务-microtask-更新应用程序状态的任务"><a href="#微任务-microtask-更新应用程序状态的任务" class="header-anchor">#</a> 微任务 microtask：更新应用程序状态的任务</h3> <ul><li><code>Promise.then</code> 回调，</li> <li><code>MutationObserver</code>，</li> <li><code>queueMicrotask</code>,</li> <li><code>process.nextTick</code>（Node.js 独有）</li></ul> <p>其中 <code>setImmediate</code> 和 <code>process.nextTick</code> 是 Node.js 的实现</p> <h2 id="浏览器事件循环"><a href="#浏览器事件循环" class="header-anchor">#</a> 浏览器事件循环</h2> <p><strong>事件循环（Event Loop）</strong> 是让 JavaScript 做到既是「单线程」，又绝对「不会阻塞」的核心机制，也是 JavaScript 「并发模型（Concurrency Model）」的基础，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。</p> <blockquote><p>说的更简单一点：Event Loop 只不过是实现异步的一种机制而已。</p></blockquote> <h3 id="队列"><a href="#队列" class="header-anchor">#</a> 队列</h3> <p><strong>队列执行时机</strong></p> <ul><li>宏任务队列：优先级低于微任务队列，一般也会比 animation 队列优先级低，但不是绝对。</li> <li>微任务队列：会在 JavaScript 调用栈为空的时候立即执行。</li> <li>animation 队列：会在页面渲染前执行。</li> <li>idle 队列：优先级最低，当浏览器有空闲时间的时候才会执行。</li></ul> <p><strong>队列特性</strong></p> <ul><li>任务队列：每次只执行一个任务，如果有另一个任务加进来，就添加到队列尾部。</li> <li>微任务队列：也是一直执行，直到队列为空，但是，如果处理微任务过程中有新的微任务加进来，加入添加的速度比执行快，那么就会永远执行微任务，事件循环会被阻塞，直到微任务队列完全清空，这就是它会阻止渲染的原因。（微任务的执行会因为 Javascript 堆栈的情况有所不同）</li> <li>动画帧回调队列( rAF(<code>requestAnimationFrame</code>) 回调队列)(动画队列)：会一直执行，直到队列中所有的任务都完成，如果在动画回调内部又有动画回调，它们会在下一帧执行。</li> <li>idle 队列(rIC(<code>requestIdleCallback</code>)回调队列)：每次只会执行一个任务。任务完成后会检查是否还有空闲时间，有的话会继续执行下一个任务，没有则等到下次有空闲时间再执行。需要注意的是此队列中的任务也有可能阻塞页面，当空闲时间用完后任务不会主动退出。如果任务占用时间较长，一般会将任务拆分成多个阶段，执行完一个阶段后检查还有没有空闲时间，有则继续，无则注册一个新的 idle 队列任务，然后退出当前任务。</li></ul> <h3 id="任务队列-task-queue"><a href="#任务队列-task-queue" class="header-anchor">#</a> 任务队列 Task Queue</h3> <p>一个 Event Loop 会有一个或多个 Task Queue，这是一个先进先出（FIFO）的有序列表，存放着来自不同 Task Source（任务源）的 Task。</p> <p>在 HTML 标准中，定义了几种常见的 Task Source：</p> <ol><li>DOM manipulation（DOM 操作）；</li> <li>User interaction（用户交互）；</li> <li>Networking（网络请求）；</li> <li>History traversal（History API 操作）。</li></ol> <p>Task Source 的定义非常的宽泛，常见的鼠标、键盘事件，AJAX，数据库操作（例如 IndexedDB），
以及定时器相关的 setTimeout、setInterval 等等都属于 Task Source，所有来自这些 Task Source
的 Task 都会被放到对应的 Task Queue 中等待处理。</p> <p>对于 Task、Task Queue 和 Task Source，有如下规定：</p> <ol><li>来自相同 Task Source 的 Task，必须放在同一个 Task Queue 中；</li> <li>来自不同 Task Source 的 Task，可以放在不同的 Task Queue 中；</li> <li>同一个 Task Queue 内的 Task 是按到达的先后顺序执行的；</li> <li>但对于不同的 Task Queue（Task Source），浏览器会进行调度，允许优先执行来自特定 Task Source 的 Task。</li></ol> <blockquote><p>例如，鼠标、键盘事件和网络请求都有各自的 Task Queue，当两者同时存时，浏览器可以「优先从用户交互」相关的 Task Queue 中挑选 Task 并执行，比如这里的鼠标、键盘事件，从而保证流畅的用户体验。</p></blockquote> <h3 id="调用栈和任务队列关系图"><a href="#调用栈和任务队列关系图" class="header-anchor">#</a> 调用栈和任务队列关系图</h3> <blockquote><p>当执行（浏览器将解析此脚本标记并创建任务） script 标签内的代码时（或者执行 <code>main.js</code> 入口文件），将会有一个类似 main 的函数，它指代 script 标签内的整体代码（文件自身）。</p></blockquote> <p>调用栈是一个栈结构，函数调用会形成一个栈帧，帧中包含了当前执行函数的参数和局部变量等上下文信息，函数执行完后，它的执行上下文会从栈中弹出。</p> <p>调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当函数执行完成后，就会从栈顶移出，直到栈内被清空。</p> <p>下图就是调用栈和任务队列的关系图：</p> <p><img src="/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E8%B0%83%E7%94%A8%E6%A0%88%E5%92%8C%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="调用栈和任务队列的关系图"></p> <p><strong>JavaScript Runtime 的整个运行流程</strong></p> <ol><li>主线程不断循环；</li> <li>对于「同步任务」，创建执行上下文（<a href="https://tc39.es/ecma262/#sec-execution-contexts" target="_blank" rel="noopener noreferrer">Execution Context<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>），按顺序进入执行栈（参考 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#calling-scripts" target="_blank" rel="noopener noreferrer">Calling scripts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）；</li> <li>对于异步任务：
<ul><li>与步骤 2 相同，同步执行这段代码；</li> <li>将相应的 Task（或 Microtask）添加到 Event Loop 的任务队列；</li> <li>由其他线程来执行具体的异步操作。
<blockquote><p>其他线程是指：尽管 JavaScript 是单线程的，但浏览器内核是多线程的，它会将 GUI 渲染、定时器触发、HTTP 请求等工作交给专门的线程来处理。</p> <p>另外，在 Node.js 中，异步操作会优先由 OS 或第三方系统提供的异步接口来执行，然后才由线程池处理。</p></blockquote></li></ul></li> <li>当主线程执行完当前执行栈中的所有任务，就会去读取 Event Loop 的任务队列，取出并执行任务；</li> <li>重复以上步骤。</li></ol> <h3 id="event-loop-处理模型"><a href="#event-loop-处理模型" class="header-anchor">#</a> Event Loop 处理模型</h3> <ol><li>执行 Task：从 Task Queue 中取出最老的一个 Task 并执行；如果没有 Task，直接跳过。</li> <li>执行 Microtasks：遍历 Microtask Queue 并执行所有 Microtask（参考 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener noreferrer">Perform a microtask checkpoint<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）。</li> <li>进入 Update the rendering（更新渲染）阶段：
<ol><li>设置 Performance API 中 now() 的返回值。<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance" target="_blank" rel="noopener noreferrer">Performance API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 属于 <a href="https://www.w3.org/TR/hr-time/" target="_blank" rel="noopener noreferrer">W3C High Resolution Time API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的一部分，用于前端性能测量，能够细粒度的测量首次渲染、首次渲染内容等的各项绘制指标，是前端性能追踪的重要技术手段，感兴趣的同学可关注。</li> <li>遍历本次 Event Loop 相关的 Documents，执行更新渲染。在迭代执行过程中，浏览器会根据各种因素判断是否要跳过本次更新。</li> <li>当浏览器确认继续本次更新后，处理更新渲染相关工作：
<ol><li>触发各种事件：Resize、Scroll、Media Queries、CSS Animations、Fullscreen API。</li> <li>执行 animation frame callbacks，window.<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener noreferrer">requestAnimationFrame<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 就在这里。</li> <li>更新 intersection observations，也就是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener noreferrer">Intersection Observer API<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>（可用于图片懒加载）。更新渲染和 UI，将最终结果提交到界面上。</li></ol></li></ol></li></ol> <p>用一张简图来描述一下：</p> <p><img src="/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/Event%20Loop%20%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B.jpeg" alt="Event Loop 事件模型"></p> <h2 id="node-js-事件循环"><a href="#node-js-事件循环" class="header-anchor">#</a> Node.js 事件循环</h2> <h3 id="与浏览器的不同"><a href="#与浏览器的不同" class="header-anchor">#</a> 与浏览器的不同</h3> <ul><li>没有脚本解析事件（不用从 HTML 中挑选 JavaScript，而是直接给它一个 JavaScript 文件并运行它）</li> <li>没有用户交互</li> <li>没有动画帧回调(requestAnimationCallback)</li> <li>没有渲染管道(rendering pipeline)</li></ul> <h3 id="队列-2"><a href="#队列-2" class="header-anchor">#</a> 队列</h3> <ul><li><p>宏任务队列</p> <ul><li>timers 定时器阶段（<code>setTimeout</code>, <code>setInterval</code>）</li> <li>轮询 poll 阶段（事件回调、XHR请求、磁盘读写）</li> <li>check 阶段（<code>setImmediate</code>）</li></ul></li> <li><p>微任务队列</p> <ul><li><code>Promise</code> 队列，工作原理与浏览器 <code>Promise</code> 相同 — 每个任务完成后，将运行 <code>Promise</code> 微任务队列。</li> <li>也是在每个任务完成后，运行 <code>nextTick</code> 队列，与 <code>Promise</code> 的主要区别是，如果同时拥有 <code>Promise</code> 和 <code>nextTick</code> 回调， <code>nextTick</code> 回调会在  <code>Promise</code> 之前执行（<code>nextTick</code> 回调优先级高于 <code>Promise</code>）。</li></ul></li></ul> <h3 id="整个-node-js-的运行原理"><a href="#整个-node-js-的运行原理" class="header-anchor">#</a> 整个 Node.js 的运行原理</h3> <p>从左到右，从上到下，Node.js 被分为了四层，分别是 应用层、V8引擎层、Node API 层 和 LIBUV 层。</p> <p><img src="/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/%E6%95%B4%E4%B8%AANode%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt="整个 Node.js 的运行原理"></p> <ul><li>应用层： 即 JavaScript 交互层，常见的就是 Node.js 的模块，比如 <code>http</code>，<code>fs</code></li> <li>V8 引擎层： 即利用 V8 引擎来解析 JavaScript 语法，进而和下层 API 交互</li> <li>Node API 层： 为上层模块提供系统调用，一般是由 C 语言来实现，和操作系统进行交互 。</li> <li>LIBUV 层： 是跨平台的底层封装，实现了 事件循环、文件操作等，是 Node.js 实现异步的核心 。</li></ul> <h3 id="什么是事件循环"><a href="#什么是事件循环" class="header-anchor">#</a> 什么是事件循环？</h3> <p>事件循环使 <code>Node.js</code> 可以通过将操作转移到系统内核中来执行非阻塞 <code>I/O</code> 操作（尽管 <code>JavaScript</code> 是单线程的）。</p> <h3 id="事件循环机制解析"><a href="#事件循环机制解析" class="header-anchor">#</a> 事件循环机制解析</h3> <p><code>Node.js</code> 启动时，它将初始化事件循环，处理提供的输入脚本（或放入 REPL），这些脚本可能会进行「异步 API」 调用，调度「计时器」或调用 <code>process.nextTick</code>， 然后开始处理事件循环。</p> <p>下面的图表展示了事件循环操作顺序的简化概览。</p> <div class="language- extra-class"><pre class="language-text"><code>   ┌───────────────────────────┐
┌─&gt;│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │&lt;─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
</code></pre></div><p><em>注意：每个框被称为事件循环机制的一个阶段。</em></p> <ol><li>每个阶段都有一个要执行的回调 FIFO 队列。</li> <li>当事件循环进入给定阶段时，它将执行该阶段特定的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或执行回调的最大数量为止，当队列为空或达到回调限制时，事件循环移至下一个阶段。</li> <li>当所有阶段被顺序执行一次后，称 事件循环完成了一个 tick</li></ol> <h3 id="各阶段概述"><a href="#各阶段概述" class="header-anchor">#</a> 各阶段概述</h3> <ul><li>定时器(timer)：本阶段执行已经被 <code>setTimeout()</code> 和 <code>setInterval()</code> 的调度回调函数。</li> <li>待定回调(pending callbacks)：执行延迟到下一个循环迭代的 I/O 回调。（上一个循环 poll 阶段还没来得及处理的回调）</li> <li>idle, prepare：仅系统内部使用。</li> <li>轮询(poll)： 检索新的 I/O 事件；执行与 I/O 相关的回调（除了关闭回调，那些由计时器和 <code>setImmediate()</code> 调度的之外），其余情况 node 将适当的时候在此阻塞。</li> <li>检测(check)：<code>setImmediate()</code> 回调在这里执行。</li> <li>关闭的回调函数(close callbacks)：一些关闭的回调函数，例如 <code>socket.on('close', ...)</code></li></ul> <h3 id="timers-计时器阶段"><a href="#timers-计时器阶段" class="header-anchor">#</a> timers 计时器阶段</h3> <p>计时器可以在回调后面指定时间阈值，但这不是我们希望其执行的确切时间。计时器回调将在经过指定的时间后尽早运行。但是，操作系统调度或其他回调的运行可能会延迟它们。-- <code>执行的实际时间不确定</code></p> <p><strong>注意</strong>：从技术上讲，轮询 <code>poll</code> 阶段控制计时器的执行时间。</p> <p>注意：为防止轮询 <code>poll</code> 阶段使事件循环陷入饥饿状态 (一直等待 <code>poll</code> 事件)，libuv 还具有一个硬最大值限制来停止轮询。</p> <h3 id="pending-callbacks-阶段"><a href="#pending-callbacks-阶段" class="header-anchor">#</a> pending callbacks 阶段</h3> <p>此阶段执行某些系统操作的回调，例如 TCP 错误。 举个例子，如果 TCP 套接字在尝试连接时收到 ECONNREFUSED，则某些 * nix 系统希望等待报告错误。 这将会在 <code>pending callbacks</code> 阶段排队执行。</p> <h3 id="轮询-poll-阶段"><a href="#轮询-poll-阶段" class="header-anchor">#</a> 轮询 poll 阶段</h3> <p>轮询阶段具有两个主要功能：</p> <ul><li>计算应该阻塞并轮询  I/O 的时间</li> <li>处理轮询队列 (poll queue) 中的事件</li></ul> <p>当事件循环进入轮询 <code>poll</code> 阶段并且没有任何计时器调度 (timers scheduled) 时，将发生以下两种情况之一：</p> <ul><li><p>如果轮询队列 (poll queue) 不为空，则事件循环将遍历其回调队列，使其同步执行，
直到队列用尽或达到与系统相关的硬限制为止。</p></li> <li><p>如果轮询队列为空，则会发生以下两种情况之一：</p> <ul><li>如果已通过 <code>setImmediate</code> 调度了脚本，则事件循环将结束轮询 <code>poll</code> 阶段，并继续执行检查 <code>check</code> 阶段以执行那些调度的脚本。</li> <li>如果脚本并没有 <code>setImmediate</code> 设置回调，则事件循环将等待 <code>poll</code> 队列中的回调，然后立即执行它们。</li></ul></li></ul> <p>一旦轮询队列 (poll queue) 为空，事件循环将检查哪些计时器 <code>timer</code> 已经到时间。如果一个或多个计时器 <code>timer</code> 准备就绪，则事件循环将返回到计时器阶段，以执行这些计时器的回调。</p> <h3 id="检查阶段-check"><a href="#检查阶段-check" class="header-anchor">#</a> 检查阶段 check</h3> <p>此阶段允许在轮询 <code>poll</code> 阶段完成后立即执行回调。 如果轮询 <code>poll</code> 阶段处于空闲，并且脚本已使用 <code>setImmediate</code> 进入 <code>check</code> 队列，则事件循环可能会进入 <code>check</code> 阶段，而不是在 <code>poll</code> 阶段等待。</p> <h3 id="close-callbacks-阶段"><a href="#close-callbacks-阶段" class="header-anchor">#</a> close callbacks 阶段</h3> <p>如果套接字或句柄突然关闭（例如 <code>socket.destroy</code>），则在此阶段将发出 'close' 事件。否则它将通过 <code>process.nextTick</code> 发出。</p> <h3 id="setimmediate-vs-settimeout"><a href="#setimmediate-vs-settimeout" class="header-anchor">#</a> <code>setImmediate</code> vs <code>setTimeout</code></h3> <p><code>setImmediate</code> 和 <code>setTimeout</code> 相似，但是根据调用时间的不同，它们的行为也不同。</p> <ul><li><code>setImmediate</code> 设计为在当前轮询 <code>poll</code> 阶段完成后执行脚本。</li> <li><code>setTimeout</code> 计划在以毫秒为单位的最小阈值过去之后运行脚本。</li></ul> <p>计时器的执行顺序将根据调用它们的上下文而有所不同。 如果两者都是主模块 (main module) 中调用的，则时序将受到进程性能的限制（这可能会受到计算机上运行的其他应用程序的影响）。</p> <ul><li>如果我们运行以下不在 I/O 回调（即主模块）内的脚本，则两个计时器的执行顺序是不确定的，因为它受进程性能的约束</li> <li>如果这两个调用在一个 I/O 回调中，那么 <code>immediate</code> 总是执行第一</li></ul> <p>Q：那为什么在外部 (比如主代码部分 mainline) 这两者的执行顺序不确定呢？</p> <p>A：在 mainline 部分执行 <code>setTimeout</code> 设置定时器 (没有写入队列呦)，与 <code>setImmediate</code> 写入 <code>check</code> 队列。mainline 执行完开始事件循环，第一阶段是 <code>timers</code>，这时候 <code>timers</code> 队列可能为空，也可能有回调；如果没有那么执行 <code>check</code> 队列的回调，下一轮循环在检查并执行 <code>timers</code> 队列的回调；如果有就先执行<code>timers</code> 的回调，再执行 <code>check</code> 阶段的回调。因此这是 <code>timers</code> 的不确定性导致的。</p> <h3 id="process-nexttick"><a href="#process-nexttick" class="header-anchor">#</a> <code>process.nextTick</code></h3> <h4 id="理解-process-nexttick"><a href="#理解-process-nexttick" class="header-anchor">#</a> <strong>理解 <code>process.nextTick</code></strong>：</h4> <p>你可能已经注意到 <code>process.nextTick</code> 并未显示在图中，即使它是「异步 API」 的一部分也是如此。这是因为 <code>process.nextTick</code> 从技术上讲不是事件循环的一部分。相反，无论事件循环的当前阶段如何，都将在当前操作完成之后处理 <code>nextTickQueue</code>。 在此，将操作定义为在 C/C ++ 处理程序基础下过渡并处理需要执行的 JavaScript。</p> <p>在给定阶段里可以在任意时间调用 <code>process.nextTick</code>，传递给 <code>process.nextTick</code> 的所有回调都将在事件循环继续之前得到解决。这可能会导致一些不良情况，因为它允许您通过进行递归 <code>process.nextTick</code> 调用来让 I/O 处于 &quot;饥饿&quot; 状态，从而防止事件循环进入轮询 <code>poll</code> 阶段。</p> <h4 id="process-nexttick-vs-setimmediate"><a href="#process-nexttick-vs-setimmediate" class="header-anchor">#</a> <strong><code>process.nextTick()</code> vs <code>setImmediate()</code></strong>：</h4> <p>它们的调用方式很相似，但是名称让人困惑。</p> <ul><li><code>process.nextTick</code> 在同一阶段立即触发</li> <li><code>setImmediate</code> fires on the following iteration or 'tick' of the event loop (在事件循环接下来的阶段迭代中执行 - <code>check</code> 阶段)。</li></ul> <p>本质上，名称应互换。 <code>process.nextTick</code> 比 <code>setImmediate</code> 触发得更快，但由于历史原因，不太可能改变。 进行此切换将破坏 npm 上很大一部分软件包。 每天都会添加更多的新模块，这意味着我们每天都在等待，更多潜在的损坏发生。 尽管它们令人困惑，但名称本身不会改变。</p> <p>建议开发人员在所有情况下都使用 <code>setImmediate</code>，因为这样更容易推理（并且代码与各种环境兼容，例如浏览器 JS。）- 但是如果理解底层原理，就不一样。</p> <h4 id="为什么还用-process-nexttick"><a href="#为什么还用-process-nexttick" class="header-anchor">#</a> <strong>为什么还用 <code>process.nextTick</code>？</strong></h4> <ul><li>在事件循环继续之前下个阶段允许开发者处理错误，清理所有不必要的资源，或者重新尝试请求。</li> <li>有时需要让回调在事件循环继续下个阶段之前运行 (At times it's necessary to allow a callback to run after the call stack has unwound but before the event loop continues.)。</li></ul> <h4 id="process-nexttick-在事件循环的位置"><a href="#process-nexttick-在事件循环的位置" class="header-anchor">#</a> <strong><code>process.nextTick</code> 在事件循环的位置</strong>：</h4> <div class="language- extra-class"><pre class="language-text"><code>           ┌───────────────────────────┐
        ┌─&gt;│           timers          │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        │  │     pending callbacks     │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        |  |     idle, prepare         │
        |  └─────────────┬─────────────┘
  nextTickQueue     nextTickQueue
        |  ┌─────────────┴─────────────┐
        |  │           poll            │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        │  │           check           │
        │  └─────────────┬─────────────┘
        │           nextTickQueue
        │  ┌─────────────┴─────────────┐
        └──┤       close callbacks     │
           └───────────────────────────┘
</code></pre></div><p>下图补充了官方并没有提及的 <code>Microtasks</code> 微任务:</p> <p><img src="/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/process.nextTick%20%E5%9C%A8%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="process.nextTick 在事件循环的位置"></p> <h3 id="microtasks-微任务"><a href="#microtasks-微任务" class="header-anchor">#</a> Microtasks 微任务</h3> <blockquote><p>微任务会在主线之后和事件循环的每个阶段之后立即执行。</p></blockquote> <p>如果您熟悉 JavaScript 事件循环，那么应该对微任务不陌生，这些微任务在 Node 中的工作方式相同。</p> <p>在 Node 领域，微任务是来自以下对象的回调：</p> <ul><li><code>process.nextTick()</code></li> <li><code>then()</code> handlers for resolved or rejected Promises</li></ul> <p>在主线结束后以及事件循环的每个阶段之后，立即运行微任务回调。（高版本 Node.js 与浏览器行为一致）</p> <p>resolved 的 <code>promise.then</code> 回调像微处理一样执行，就像 <code>process.nextTick</code> 一样。 虽然，如果两者都在同一个微任务队列中，则将首先执行 <code>process.nextTick</code> 的回调。</p> <p>优先级 <code>process.nextTick</code> &gt; <code>promise.then</code> = <code>queueMicrotask</code></p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ol><li>Node.js 的事件循环分为 6 个阶段</li> <li>浏览器和 Node 环境下，microtask 任务队列的执行时机不同
2.1 Node.js 中，microtask 在事件循环的各个阶段之间执行（高版本 Node.js 与浏览器行为一致，在每个 macrotask 执行完之后执行）
2.2 浏览器端，microtask 在事件循环的每个 macrotask 执行完之后执行</li> <li>递归的调用 <code>process.nextTick()</code> 会导致I/O starving，官方推荐使用 <code>setImmediate()</code></li></ol> <h2 id="node-的事件循环机制-来自-node-js事件循环eventloop机制-异步原理"><a href="#node-的事件循环机制-来自-node-js事件循环eventloop机制-异步原理" class="header-anchor">#</a> Node 的事件循环机制（来自 <a href="https://www.youtube.com/watch?v=5uCopOqHIok&amp;t=166s" target="_blank" rel="noopener noreferrer">Node.js事件循环EventLoop机制 异步原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>）</h2> <p>libuv 是一个高性能的，事件驱动的I/O库</p> <p>这个库负责各种回调函数的执行顺序，毕竟异步任务最后还是要回到主线程，排队等待执行，这就是事件循环。</p> <p>1、定时器</p> <p>Node 提供了四个定时器，让任务可以在指定的时间运行：<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、<code>process.nextTick</code>。前两个是语言的标准，后两个是 Node 独有的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 5 3 4 1 2</span>
</code></pre></div><p>2、同步任务和异步任务</p> <p>同步任务总是比异步任务更早执行</p> <p>3、本轮循环和次轮循环</p> <p>异步任务可以分为两种：追加在本轮循环的异步任务、追加在次轮循环的异步任务。所谓“循环”，指的是事件循环（event loop）。这是 JavaScript 引擎处理异步任务的方式，本轮循环一定早于次轮循环执行。</p> <p>Node 规定，<code>process.nextTick</code> 和 <code>Promise</code> 的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们，且 <code>process.nextTick</code> 是所有异步任务里面最快执行的。</p> <p>而 <code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code> 的回调函数，追加在次轮循环。</p> <p>4、微任务</p> <p>根据语言规定，Promise 对象的回调函数，会进入异步任务里面的“微任务”(microtask)队列。微任务队列追加在 <code>process.nextTick</code> 队列的后面，也属于本轮循环。所以上面的代码总是先输出 3，再输出 4。</p> <p>至此，本轮循环的执行顺序：同步任务 =&gt; <code>process.nextTick()</code> =&gt; 微任务</p> <p>5、事件循环执行顺序</p> <p>Node 只有一个主线程，事件循环是在主线程上完成的。开始执行脚本时，会先进行事件循环的初始化，但是这时事件循环还没有开始，会先完成下面的事情：同步任务、发出异步任务、规划定时器生效时间、执行 <code>process.nextTick</code> 等等。最后上面事情都干完了，事件循环就正式开始了。事件循环会无限次地执行，一轮又一轮。只有异步任务的回调函数队列清空了，才会停止执行。每一轮的事件循环，分成六个阶段，这些阶段会依次执行：</p> <ol><li>timers: 该阶段执行定时器的回调，如 <code>setTimeout</code> 和 <code>setInterval</code></li> <li>I/O callbacks: 该阶段执行除了 close 事件，定时器和 <code>setImmediate</code> 的回调外的所有回调</li> <li>idle, prepare: 内部使用</li> <li>poll: 等待新的 I/O 事件，node 在一些特殊的情况下会阻塞在这里，比如服务器的响应、用户移动鼠标等等</li> <li>check: <code>setImmediate</code> 的回调会在这个阶段执行</li> <li>close callbacks: 例如 <code>socket.on('close', ...)</code> 这种 close 事件的回调</li></ol> <p>6、事件循环示例一</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> timeoutScheduled <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 异步任务一：100ms 后执行的定时器</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'timer: '</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> delay <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> timeoutScheduled
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>delay<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token comment">// 异步任务二：文件读取后，有一个 200 ms 的回调函数</span>
fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'test.js'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> content</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> startCallback <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startCallback <span class="token operator">&lt;</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// nothing</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 结果：取决于 读取文件所花费的时间是否大于 100ms</span>
<span class="token comment">//  小于 100ms：先执行异步任务二再执行异步任务一</span>
<span class="token comment">//  大于 100ms：先执行异步任务一再执行异步任务二</span>
</code></pre></div><p>7、事件循环示例二</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 输出 2 1</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>

fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'test.js'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 输出 2 1</span>
</code></pre></div><h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li>⭐️ <a href="https://zhuanlan.zhihu.com/p/34229323" target="_blank" rel="noopener noreferrer">深入理解 JavaScript Event Loop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>⭐️ <a href="https://segmentfault.com/a/1190000019154514" target="_blank" rel="noopener noreferrer">再谈谈 Promise, setTimeout, rAF, rIC<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844903761949753352" target="_blank" rel="noopener noreferrer">浏览器与Node的事件循环(Event Loop)有何区别?—浪里行舟<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="http://lynnelv.github.io/js-event-loop-browser" target="_blank" rel="noopener noreferrer">深入理解js事件循环机制（浏览器篇）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://learnku.com/articles/38802" target="_blank" rel="noopener noreferrer">Node.js 事件循环-比官方更全面—官方文档翻译<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener noreferrer">Node.js 事件循环，定时器和 process.nextTick()—官方文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://zhuanlan.zhihu.com/p/267273074" target="_blank" rel="noopener noreferrer">当事件循环遇到更新渲染—大转转FE<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.youtube.com/watch?v=5uCopOqHIok&amp;t=166s" target="_blank" rel="noopener noreferrer">Node.js事件循环EventLoop机制 异步原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/JavaScript/深入原理/上下文与作用域.html" class="prev">
        上下文与作用域
      </a></span> <span class="next"><a href="/JavaScript/深入原理/原型与原型链.html">
        原型原型链
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d6181b04.js" defer></script><script src="/assets/js/2.733019b2.js" defer></script><script src="/assets/js/25.85eb4b5d.js" defer></script>
  </body>
</html>
